"""
NexusTradeAI - Modular Trading Strategy Framework
===============================================

This module implements a flexible and extensible trading strategy framework
that supports multiple algorithm types, backtesting, and AI integration.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import logging

# Simple technical indicators without TA-Lib dependency
def simple_moving_average(data: np.array, period: int) -> np.array:
    """Calculate Simple Moving Average"""
    return pd.Series(data).rolling(window=period).mean().values

def rsi(data: np.array, period: int = 14) -> np.array:
    """Calculate RSI indicator"""
    delta = pd.Series(data).diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return (100 - (100 / (1 + rs))).values

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    STRONG_BUY = "strong_buy"
    STRONG_SELL = "strong_sell"

class StrategyType(Enum):
    """Strategy categories"""
    TREND_FOLLOWING = "trend_following"
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    SCALPING = "scalping"
    ARBITRAGE = "arbitrage"
    AI_POWERED = "ai_powered"
    HYBRID = "hybrid"

@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy"""
    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self):
        return (f"Signal({self.symbol}: {self.signal_type.value} @ "
                f"{self.entry_price:.4f} with {self.confidence:.2f} confidence)")

@dataclass
class MarketData:
    """Market data container for strategy analysis"""
    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    
    def to_dict(self) -> Dict:
        return {
            'timestamp': self.timestamp,
            'open': self.open,
            'high': self.high,
            'low': self.low,
            'close': self.close,
            'volume': self.volume
        }

class TechnicalIndicators:
    """Technical analysis indicators library"""

    @staticmethod
    def sma(prices: np.ndarray, period: int) -> np.ndarray:
        """Simple Moving Average"""
        return simple_moving_average(prices, period)

    @staticmethod
    def ema(prices: np.ndarray, period: int) -> np.ndarray:
        """Exponential Moving Average"""
        return pd.Series(prices).ewm(span=period).mean().values

    @staticmethod
    def rsi(prices: np.ndarray, period: int = 14) -> np.ndarray:
        """Relative Strength Index"""
        return rsi(prices, period)

    @staticmethod
    def macd(prices: np.ndarray, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """MACD indicator"""
        ema_fast = pd.Series(prices).ewm(span=fast).mean()
        ema_slow = pd.Series(prices).ewm(span=slow).mean()
        macd_line = ema_fast - ema_slow
        signal_line = macd_line.ewm(span=signal).mean()
        histogram = macd_line - signal_line
        return macd_line.values, signal_line.values, histogram.values

    @staticmethod
    def bollinger_bands(prices: np.ndarray, period: int = 20, std_dev: int = 2) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Bollinger Bands"""
        sma = pd.Series(prices).rolling(window=period).mean()
        std = pd.Series(prices).rolling(window=period).std()
        upper = sma + (std * std_dev)
        lower = sma - (std * std_dev)
        return upper.values, sma.values, lower.values

    @staticmethod
    def stochastic(high: np.ndarray, low: np.ndarray, close: np.ndarray, k_period: int = 14, d_period: int = 3) -> Tuple[np.ndarray, np.ndarray]:
        """Stochastic Oscillator"""
        lowest_low = pd.Series(low).rolling(window=k_period).min()
        highest_high = pd.Series(high).rolling(window=k_period).max()
        k_percent = 100 * ((pd.Series(close) - lowest_low) / (highest_high - lowest_low))
        d_percent = k_percent.rolling(window=d_period).mean()
        return k_percent.values, d_percent.values

    @staticmethod
    def atr(high: np.ndarray, low: np.ndarray, close: np.ndarray, period: int = 14) -> np.ndarray:
        """Average True Range"""
        high_low = pd.Series(high) - pd.Series(low)
        high_close = np.abs(pd.Series(high) - pd.Series(close).shift())
        low_close = np.abs(pd.Series(low) - pd.Series(close).shift())
        true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        return true_range.rolling(window=period).mean().values

class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies
    """
    
    def __init__(self, name: str, strategy_type: StrategyType, parameters: Dict[str, Any] = None):
        self.name = name
        self.strategy_type = strategy_type
        self.parameters = parameters or {}
        self.is_active = True
        self.last_signal_time = None
        self.performance_metrics = {
            'total_signals': 0,
            'successful_signals': 0,
            'win_rate': 0.0,
            'avg_confidence': 0.0
        }
    
    @abstractmethod
    def generate_signal(self, market_data: List[MarketData]) -> Optional[TradingSignal]:
        """
        Generate trading signal based on market data
        Must be implemented by each strategy
        """
        pass
    
    @abstractmethod
    def validate_signal(self, signal: TradingSignal, current_price: float) -> bool:
        """
        Validate if the generated signal should be executed
        """
        pass
    
    def update_performance(self, signal_success: bool, confidence: float):
        """Update strategy performance metrics"""
        self.performance_metrics['total_signals'] += 1
        if signal_success:
            self.performance_metrics['successful_signals'] += 1
        
        self.performance_metrics['win_rate'] = (
            self.performance_metrics['successful_signals'] / 
            self.performance_metrics['total_signals']
        )
        
        # Update rolling average confidence
        total_signals = self.performance_metrics['total_signals']
        current_avg = self.performance_metrics['avg_confidence']
        self.performance_metrics['avg_confidence'] = (
            (current_avg * (total_signals - 1) + confidence) / total_signals
        )
    
    def get_info(self) -> Dict[str, Any]:
        """Get strategy information and parameters"""
        return {
            'name': self.name,
            'type': self.strategy_type.value,
            'active': self.is_active,
            'parameters': self.parameters,
            'performance': self.performance_metrics
        }

class MovingAverageCrossoverStrategy(BaseStrategy):
    """
    Classic Moving Average Crossover Strategy
    Generates buy signals when short MA crosses above long MA
    """

    def __init__(self, short_period: int = 20, long_period: int = 50, rsi_confirmation: bool = True):
        super().__init__(
            name=f"MA_Cross_{short_period}_{long_period}",
            strategy_type=StrategyType.TREND_FOLLOWING,
            parameters={
                'short_period': short_period,
                'long_period': long_period,
                'rsi_confirmation': rsi_confirmation,
                'rsi_buy_threshold': 50,
                'rsi_sell_threshold': 50
            }
        )

    def generate_signal(self, market_data: List[MarketData]) -> Optional[TradingSignal]:
        if len(market_data) < self.parameters['long_period']:
            return None

        # Convert to pandas DataFrame for easier analysis
        df = pd.DataFrame([data.to_dict() for data in market_data])
        closes = df['close'].values

        # Calculate moving averages
        short_ma = TechnicalIndicators.sma(closes, self.parameters['short_period'])
        long_ma = TechnicalIndicators.sma(closes, self.parameters['long_period'])

        # Get current and previous values
        current_short = short_ma[-1]
        current_long = long_ma[-1]
        prev_short = short_ma[-2]
        prev_long = long_ma[-2]

        # Check for crossover
        signal_type = None
        confidence = 0.0

        # Bullish crossover (short MA crosses above long MA)
        if prev_short <= prev_long and current_short > current_long:
            signal_type = SignalType.BUY
            confidence = 0.7

        # Bearish crossover (short MA crosses below long MA)
        elif prev_short >= prev_long and current_short < current_long:
            signal_type = SignalType.SELL
            confidence = 0.7

        if signal_type is None:
            return None

        # RSI confirmation if enabled
        if self.parameters['rsi_confirmation']:
            rsi = TechnicalIndicators.rsi(closes)[-1]

            if signal_type == SignalType.BUY and rsi > self.parameters['rsi_buy_threshold']:
                confidence += 0.2
            elif signal_type == SignalType.SELL and rsi < self.parameters['rsi_sell_threshold']:
                confidence += 0.2
            else:
                confidence -= 0.1  # Reduce confidence if RSI doesn't confirm

        # Create signal
        current_price = closes[-1]
        stop_loss = current_price * 0.95 if signal_type == SignalType.BUY else current_price * 1.05
        take_profit = current_price * 1.10 if signal_type == SignalType.BUY else current_price * 0.90

        return TradingSignal(
            symbol=market_data[-1].symbol,
            signal_type=signal_type,
            confidence=min(confidence, 1.0),
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            metadata={
                'short_ma': current_short,
                'long_ma': current_long,
                'rsi': rsi if self.parameters['rsi_confirmation'] else None
            }
        )

    def validate_signal(self, signal: TradingSignal, current_price: float) -> bool:
        # Simple validation - price shouldn't have moved too much
        if signal.entry_price is None:
            return False

        price_change = abs(current_price - signal.entry_price) / signal.entry_price
        return price_change < 0.02  # Less than 2% price change
