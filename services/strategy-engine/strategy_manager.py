"""
NexusTradeAI - Strategy Manager
==============================

Orchestrates multiple trading strategies and manages their execution.
"""

import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import asyncio
import json

from strategy_framework import BaseStrategy, TradingSignal, MarketData, SignalType
from strategies import (
    RSIMeanReversionStrategy, 
    MomentumBreakoutStrategy, 
    ScalpingStrategy
)

logger = logging.getLogger(__name__)

class StrategyManager:
    """
    Manages multiple trading strategies and coordinates their signals
    """
    
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.active_signals: List[TradingSignal] = []
        self.signal_history: List[TradingSignal] = []
        self.market_data_cache: Dict[str, List[MarketData]] = {}
        self.performance_metrics = {
            'total_signals_generated': 0,
            'signals_executed': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'total_pnl': 0.0
        }
    
    def register_strategy(self, strategy: BaseStrategy) -> bool:
        """Register a new trading strategy"""
        try:
            if strategy.name in self.strategies:
                logger.warning(f"Strategy {strategy.name} already exists, replacing...")
            
            self.strategies[strategy.name] = strategy
            logger.info(f"Registered strategy: {strategy.name} ({strategy.strategy_type.value})")
            return True
            
        except Exception as e:
            logger.error(f"Failed to register strategy {strategy.name}: {e}")
            return False
    
    def remove_strategy(self, strategy_name: str) -> bool:
        """Remove a strategy from the manager"""
        if strategy_name in self.strategies:
            del self.strategies[strategy_name]
            logger.info(f"Removed strategy: {strategy_name}")
            return True
        return False
    
    def get_strategy(self, strategy_name: str) -> Optional[BaseStrategy]:
        """Get a specific strategy by name"""
        return self.strategies.get(strategy_name)
    
    def list_strategies(self) -> List[Dict[str, Any]]:
        """List all registered strategies with their info"""
        return [strategy.get_info() for strategy in self.strategies.values()]
    
    def update_market_data(self, symbol: str, data: MarketData):
        """Update market data for a symbol"""
        if symbol not in self.market_data_cache:
            self.market_data_cache[symbol] = []
        
        self.market_data_cache[symbol].append(data)
        
        # Keep only last 200 data points to manage memory
        if len(self.market_data_cache[symbol]) > 200:
            self.market_data_cache[symbol] = self.market_data_cache[symbol][-200:]
    
    def generate_signals(self, symbol: str) -> List[TradingSignal]:
        """Generate signals from all active strategies for a symbol"""
        if symbol not in self.market_data_cache:
            logger.warning(f"No market data available for {symbol}")
            return []
        
        market_data = self.market_data_cache[symbol]
        signals = []
        
        for strategy_name, strategy in self.strategies.items():
            if not strategy.is_active:
                continue
            
            try:
                signal = strategy.generate_signal(market_data)
                if signal:
                    signal.metadata['strategy'] = strategy_name
                    signals.append(signal)
                    self.performance_metrics['total_signals_generated'] += 1
                    logger.info(f"Signal generated by {strategy_name}: {signal}")
                    
            except Exception as e:
                logger.error(f"Error generating signal from {strategy_name}: {e}")
        
        # Store signals in history
        self.signal_history.extend(signals)
        
        # Keep only last 1000 signals in history
        if len(self.signal_history) > 1000:
            self.signal_history = self.signal_history[-1000:]
        
        return signals
    
    def validate_signals(self, signals: List[TradingSignal], current_prices: Dict[str, float]) -> List[TradingSignal]:
        """Validate signals before execution"""
        validated_signals = []
        
        for signal in signals:
            try:
                current_price = current_prices.get(signal.symbol)
                if current_price is None:
                    logger.warning(f"No current price for {signal.symbol}, skipping validation")
                    continue
                
                strategy = self.strategies.get(signal.metadata.get('strategy'))
                if strategy and strategy.validate_signal(signal, current_price):
                    validated_signals.append(signal)
                    logger.info(f"Signal validated: {signal}")
                else:
                    logger.info(f"Signal validation failed: {signal}")
                    
            except Exception as e:
                logger.error(f"Error validating signal {signal}: {e}")
        
        return validated_signals
    
    def aggregate_signals(self, signals: List[TradingSignal]) -> Dict[str, TradingSignal]:
        """
        Aggregate multiple signals for the same symbol
        Returns the highest confidence signal for each symbol
        """
        symbol_signals = {}
        
        for signal in signals:
            symbol = signal.symbol
            
            if symbol not in symbol_signals:
                symbol_signals[symbol] = signal
            else:
                # Keep the signal with higher confidence
                if signal.confidence > symbol_signals[symbol].confidence:
                    symbol_signals[symbol] = signal
        
        return symbol_signals
    
    def get_strategy_performance(self, strategy_name: str) -> Optional[Dict[str, Any]]:
        """Get performance metrics for a specific strategy"""
        strategy = self.strategies.get(strategy_name)
        if strategy:
            return strategy.performance_metrics
        return None
    
    def get_overall_performance(self) -> Dict[str, Any]:
        """Get overall performance metrics"""
        return {
            **self.performance_metrics,
            'active_strategies': len([s for s in self.strategies.values() if s.is_active]),
            'total_strategies': len(self.strategies),
            'success_rate': (
                self.performance_metrics['successful_trades'] / 
                max(self.performance_metrics['signals_executed'], 1)
            ) * 100
        }
    
    def get_recent_signals(self, limit: int = 50) -> List[Dict[str, Any]]:
        """Get recent signals with metadata"""
        recent_signals = self.signal_history[-limit:] if self.signal_history else []
        
        return [
            {
                'symbol': signal.symbol,
                'signal_type': signal.signal_type.value,
                'confidence': signal.confidence,
                'entry_price': signal.entry_price,
                'stop_loss': signal.stop_loss,
                'take_profit': signal.take_profit,
                'timestamp': signal.timestamp.isoformat(),
                'strategy': signal.metadata.get('strategy', 'unknown')
            }
            for signal in recent_signals
        ]
    
    def activate_strategy(self, strategy_name: str) -> bool:
        """Activate a strategy"""
        strategy = self.strategies.get(strategy_name)
        if strategy:
            strategy.is_active = True
            logger.info(f"Activated strategy: {strategy_name}")
            return True
        return False
    
    def deactivate_strategy(self, strategy_name: str) -> bool:
        """Deactivate a strategy"""
        strategy = self.strategies.get(strategy_name)
        if strategy:
            strategy.is_active = False
            logger.info(f"Deactivated strategy: {strategy_name}")
            return True
        return False
    
    def update_strategy_parameters(self, strategy_name: str, parameters: Dict[str, Any]) -> bool:
        """Update strategy parameters"""
        strategy = self.strategies.get(strategy_name)
        if strategy:
            strategy.parameters.update(parameters)
            logger.info(f"Updated parameters for {strategy_name}: {parameters}")
            return True
        return False
    
    def create_default_strategies(self):
        """Create and register default strategies"""
        try:
            # Moving Average Crossover (from strategy_framework.py)
            from strategy_framework import MovingAverageCrossoverStrategy
            ma_strategy = MovingAverageCrossoverStrategy(short_period=20, long_period=50)
            self.register_strategy(ma_strategy)
            
            # RSI Mean Reversion
            rsi_strategy = RSIMeanReversionStrategy(rsi_period=14, oversold=30, overbought=70)
            self.register_strategy(rsi_strategy)
            
            # Momentum Breakout
            momentum_strategy = MomentumBreakoutStrategy(period=20, volume_multiplier=1.5)
            self.register_strategy(momentum_strategy)
            
            # Scalping Strategy
            scalping_strategy = ScalpingStrategy(fast_ema=5, slow_ema=13)
            self.register_strategy(scalping_strategy)
            
            logger.info("Default strategies created and registered")
            
        except Exception as e:
            logger.error(f"Error creating default strategies: {e}")
    
    def export_configuration(self) -> Dict[str, Any]:
        """Export current configuration"""
        return {
            'strategies': {
                name: {
                    'type': strategy.strategy_type.value,
                    'active': strategy.is_active,
                    'parameters': strategy.parameters,
                    'performance': strategy.performance_metrics
                }
                for name, strategy in self.strategies.items()
            },
            'performance': self.get_overall_performance(),
            'export_timestamp': datetime.now().isoformat()
        }
    
    def import_configuration(self, config: Dict[str, Any]) -> bool:
        """Import configuration (strategies and parameters)"""
        try:
            # This would require strategy factory implementation
            # For now, just update parameters of existing strategies
            strategies_config = config.get('strategies', {})
            
            for strategy_name, strategy_config in strategies_config.items():
                if strategy_name in self.strategies:
                    strategy = self.strategies[strategy_name]
                    strategy.is_active = strategy_config.get('active', True)
                    strategy.parameters.update(strategy_config.get('parameters', {}))
            
            logger.info("Configuration imported successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error importing configuration: {e}")
            return False
